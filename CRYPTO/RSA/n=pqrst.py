# competition:BaseCTF
# filename: try_to_factors

from Crypto.Util.number import *
import random
from math import gcd
import myRSA
from sympy import true
from itertools import combinations

# QUESTION：
# flag=b'BaseCTF{}'+random.randbytes(64)
# m=bytes_to_long(flag)
#
# p,q,r,s,t=[getStrongPrime(512) for _ in range(5)]
# N=p*q*r*s*t
#
# n=p*q
e=65537
# c=pow(m,e,n)
#
#
# gift=random.randint(2,n)*(p-1)*(q-1)*(r-1)*(s-1)*(t-1)
# while gift%2==0:
#     gift//=2
N = 162692163428762295773992659007654377270271126313772302197255271375236131917158614424426498628778734679898165422129699410934825650141972454562350664161510689489443251515884304101827584411577749250383438126881931889798597627663578045519256806107514170414321556291545302688028088470848270636776466672843710163017531472049823632822203461654253767303314505996071453898533003519236112138591066133289040889933161978131399309340741554076140734156174295730180874473301361701867633594222054688204666518058106672165786417002466165926062199279674267145233283545524775943767021416906072142236079753359492846480515376121887507681663761713445807717270089017438999615422884163666812016989696908657065537508715229685120221307021151610089917537155165897740417480127289719971512938348936259
c = 113962118676826667648935023618252851875440854724310328843964819392166304653581141146631375503931008732348730639629174670963727399860571217264854300057305570824097216782800531930906801885967717639795643406206813677461127762087560021634738167845077869308515223303820469892552545806179267969169748886980836435095
gift = 863514692222931709925579242743251211976114217396765747601042357918763818732391790491059528595917786523674732369068315533549380754409535403506339052401422249684188032949680148055803474336983973622610403448963752802490806614810077181934627694570685722842963961551889267501616799757825675192653489096007790143775773378495299981666657347802233798206597104474595281241837323214457344961462510183726339545608046357281265026013496037522835659867389206279894057481600882665189079672009577651494435000349624334685832217586703242422260870866432379257259316411280539845741932725104662417642890238587876489774492067722351467773093391502588019563488688309892102039611978767690653206664257400163618467825666105966072942726011447079204869750153256054140924951306811971422635104088608275908232688385437145325481792836532453258784103533536292492138405929815964841772656055397705840797739586953744563989819811944946916720655079908564653686456283647030055622241840292127096994325415897266379446446435164189216562921252341705747891518007710533906231225283309180960546212899099652226954393826875


def is_factor(a, b):
    return b % a == 0


# 基于拉斯维加斯算法的因数分解
# 通过随机选择一个基数w，并计算其幂次，直到找到一个非平凡的因子
def las_vegas_factor(N, kphi):
    s = 0
    u = kphi
    while u % 2 == 0:
        print("wrong")
    w = random.randint(2, N - 2)
    while true:
        w_pow = pow(w, pow(2, s) * u, N)
        if w_pow == 1:
            if s == 0:
                break
            elif w_pow != -1:
                factor = gcd(N, pow(w, pow(2, s - 1) * u, N) + 1)
                if factor > 1:
                    return factor
        else:
            s += 1


# factors = []
# while True:
#     factors.append(las_vegas_factor(N, gift))
#     if factors[-1] == None:
#         break
#     N //= factors[-1] # 取factor的最后一个元素
#
# print(factors)
# for i in factors:
#     if isPrime(i) != 1:
#         print(i)


srt = 121367315989550408853238573063015605538282815990519386534517026587539952518078495142965567432227323798728765679738484564791434003329069582180473115445326964059941071101636872027440582169863137247745420375456337315800256646782863241819595740941471872759803051477676133780565951592364349220315911199748575319633
p = 11305040878738021811402439197878615954268080275926783422631842900427188149662049119033973597228180836724634867699361010520204383649921114682598253229148193
q = 10735681302825912868095663197139810022565305493164627486836513894883860598307732490956938269540406369625877588320809620427171776417839985850851728452012081
r = 12065220629404154268847771423332648956169912177824265272149645522947645275358106601922684260868397893795065500499878644811370820220730079844236829670243911
s = 11215557678579656873636794393262869574839711743001038260483773230670842818171598967864419369784934089649471289494136409813864628334111748590099942608543623
t = 9906237717211706464164358740459730309373133301767426411724458099077825419214167122866109049004942864924739763341081239620735273290918249499469902156652291
# t = N//(p*q*r*s)
print(t)
# myRSA.pqec_4_m(p, q, e, c)
# factors1 = las_vegas_factor(N, gift)
# print(isPrime(factors1), factors1)
# N4 = N // p
# factors2 = las_vegas_factor(N4, gift)
# print(isPrime(factors2), factors2)
# N3 = N4 // q
# factors3 = las_vegas_factor(N3, gift)
# print(isPrime(factors3), factors3)
# N2 = N3 // r
# factors4 = las_vegas_factor(N2, gift)
# print(isPrime(factors4), factors4)

primes = [p, q, r, s, t]
for prime_pair in combinations(primes, 2):
    # 计算 n 和 phi
    n = prime_pair[0] * prime_pair[1]
    phi = (prime_pair[0] - 1) * (prime_pair[1] - 1)
    m = myRSA.pqec_4_m(prime_pair[0], prime_pair[1], e, c)
    # 打印解密后的消息
    print(m)
